'''
Here we define functions used for building a forecast alarm for surf (generated by windswell, e.g. in the baltic sea)
'''
import pandas as pd
from datetime import datetime
import requests
from dotenv import load_dotenv
import os
import json
import openmeteo_requests
import requests_cache
from retry_requests import retry





def windmap(x):
    # translates wind direction given as degree 0 <= x <= 360 to string like "SSE"

    # dictionary for translation
    wind_directions = {
    "N": 0,
    "NNE": 22.5,
    "NE": 45,
    "ENE": 67.5,
    "E": 90,
    "ESE": 112.5,
    "SE": 135,
    "SSE": 157.5,
    "S": 180,
    "SSW": 202.5,
    "SW": 225,
    "WSW": 247.5,
    "W": 270,
    "WNW": 292.5,
    "NW": 315,
    "NNW": 337.5}

    # generate buckets of width 2*step_size for wind directions in degrees. given a degree x, find bucket and return corresponding string
    step_size = 11.25
    direction_degrees = list(wind_directions.values())
    direction_names = list(wind_directions.keys())

    # handle "N" separately, because 359 is next to 0 on the circle:
    if -step_size%360 < x or x <= step_size%360:
        return "N"
    # all other directions work by simply checking in which bucket x lies...
    else:
        for i in range(1,len(wind_directions)):
            if (direction_degrees[i]-step_size)%360 < x <= (direction_degrees[i]+step_size)%360:
                return direction_names[i]



def request(lat,lon):
    # access api, retrieve forecast, return (wind) data in dataframe

    # --- code from Open-Meteo --
    # Setup the Open-Meteo API client with cache and retry on error
    cache_session = requests_cache.CachedSession('.cache', expire_after = 3600)
    retry_session = retry(cache_session, retries = 5, backoff_factor = 0.2)
    openmeteo = openmeteo_requests.Client(session = retry_session)

    # Make sure all required weather variables are listed here
    # The order of variables in hourly or daily is important to assign them correctly below
    url = "https://api.open-meteo.com/v1/forecast"
    params = {
        "latitude": lat,
        "longitude": lon,
        "hourly": ["wind_speed_10m", "wind_direction_10m", "wind_gusts_10m"],
        "timezone": "auto",
        "temporal_resolution": "hourly_3"
    }
    responses = openmeteo.weather_api(url, params=params)

    # Process first location. Add a for-loop for multiple locations or weather models
    response = responses[0]

    # Process hourly data. The order of variables needs to be the same as requested.
    hourly = response.Hourly()
    hourly_wind_speed_10m = hourly.Variables(0).ValuesAsNumpy()
    hourly_wind_direction_10m = hourly.Variables(1).ValuesAsNumpy()
    hourly_wind_gusts_10m = hourly.Variables(2).ValuesAsNumpy()

    hourly_data = {"date": pd.date_range(
        start = pd.to_datetime(hourly.Time(), unit = "s", utc = True),
        end = pd.to_datetime(hourly.TimeEnd(), unit = "s", utc = True),
        freq = pd.Timedelta(seconds = hourly.Interval()),
        inclusive = "left"
    )}
    hourly_data["wind_speed_10m"] = hourly_wind_speed_10m
    hourly_data["wind_direction_10m"] = hourly_wind_direction_10m
    hourly_data["wind_gusts_10m"] = hourly_wind_gusts_10m

    hourly_df = pd.DataFrame(data = hourly_data)
    # --- code from Open-Meteo ---

    # massage hourly_df into format that is used in the app

    # change time format
    hourly_df['date'] = hourly_df['date'].dt.strftime('%Y-%m-%d %H:%M')

    # round data to int
    hourly_df["wind_speed_10m"] = hourly_df["wind_speed_10m"].round(decimals=0).astype(int)
    hourly_df["wind_gusts_10m"] = hourly_df["wind_gusts_10m"].round(decimals=0).astype(int)
    hourly_df["wind_direction_10m"] = hourly_df["wind_direction_10m"].round(decimals=0).astype(int)

    # rename columns and set date & time as index
    hourly_df.rename({"wind_speed_10m":"wind_speed (km/h)", "wind_gusts_10m":"wind_gusts (km/h)","wind_direction_10m":"wind_deg (°)"},axis = 1, inplace=True)
    hourly_df = hourly_df.set_index(hourly_df.date).drop(columns = "date")

    # use windmap to create new column for wind direction
    hourly_df["wind_dir"] = hourly_df["wind_deg (°)"].apply(lambda x: windmap(x))

    # reorder columns
    new_order = ["wind_speed (km/h)", "wind_gusts (km/h)", "wind_dir", "wind_deg (°)"]
    return hourly_df[new_order]



def get_forecast(spots_dict):
    # retrieve the wind forecast for all locations, spots_dict is a list of locations, saved in secrets.toml/.env

    for spot in spots_dict.keys():
        spots_dict[spot]["forecast"] = request(spots_dict[spot]["lat"],spots_dict[spot]["lon"])
    return spots_dict



def color_rows(row,spot,spots_dict):
    # highlight rows in the forecast with favourable conditions, color code by strenght of wind

    if (25 < row["wind_speed (km/h)"] <= 30) and (30 < row["wind_gusts (km/h)"]) and (
                spots_dict[spot]["wind_window"][0] <= row["wind_deg (°)"] <= spots_dict[spot]["wind_window"][1]):
        return ['background-color: lightgreen'] * len(row)
    elif (30 < row["wind_speed (km/h)"] <= 40) and (30 < row["wind_gusts (km/h)"]) and (
                spots_dict[spot]["wind_window"][0] <= row["wind_deg (°)"] <= spots_dict[spot]["wind_window"][1]):
        return ['background-color: yellow'] * len(row)
    elif (40 < row["wind_speed (km/h)"] <= 50) and (30 < row["wind_gusts (km/h)"]) and (
                spots_dict[spot]["wind_window"][0] <= row["wind_deg (°)"] <= spots_dict[spot]["wind_window"][1]):
        return ['background-color: lightsalmon'] * len(row)
    elif (50 < row["wind_speed (km/h)"]) and (30 < row["wind_gusts (km/h)"]) and (
                spots_dict[spot]["wind_window"][0] <= row["wind_deg (°)"] <= spots_dict[spot]["wind_window"][1]):
        return ['background-color: lightcoral'] * len(row)
    else:
        return ['background-color: white'] * len(row)
